// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'speed_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SpeedFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() isNull,
    required TResult Function() unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? isNull,
    TResult? Function()? unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? isNull,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
    required TResult Function(_WhileInUse value) whileInUse,
    required TResult Function(_Always value) always,
    required TResult Function(_IsNull value) isNull,
    required TResult Function(_UnableToDetermine value) unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Denied value)? denied,
    TResult? Function(_DeniedForever value)? deniedForever,
    TResult? Function(_WhileInUse value)? whileInUse,
    TResult? Function(_Always value)? always,
    TResult? Function(_IsNull value)? isNull,
    TResult? Function(_UnableToDetermine value)? unableToDetermine,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    TResult Function(_WhileInUse value)? whileInUse,
    TResult Function(_Always value)? always,
    TResult Function(_IsNull value)? isNull,
    TResult Function(_UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpeedFailureCopyWith<$Res> {
  factory $SpeedFailureCopyWith(
          SpeedFailure value, $Res Function(SpeedFailure) then) =
      _$SpeedFailureCopyWithImpl<$Res, SpeedFailure>;
}

/// @nodoc
class _$SpeedFailureCopyWithImpl<$Res, $Val extends SpeedFailure>
    implements $SpeedFailureCopyWith<$Res> {
  _$SpeedFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_DeniedCopyWith<$Res> {
  factory _$$_DeniedCopyWith(_$_Denied value, $Res Function(_$_Denied) then) =
      __$$_DeniedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DeniedCopyWithImpl<$Res>
    extends _$SpeedFailureCopyWithImpl<$Res, _$_Denied>
    implements _$$_DeniedCopyWith<$Res> {
  __$$_DeniedCopyWithImpl(_$_Denied _value, $Res Function(_$_Denied) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Denied implements _Denied {
  const _$_Denied();

  @override
  String toString() {
    return 'SpeedFailure.denied()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Denied);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() isNull,
    required TResult Function() unableToDetermine,
  }) {
    return denied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? isNull,
    TResult? Function()? unableToDetermine,
  }) {
    return denied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? isNull,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (denied != null) {
      return denied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
    required TResult Function(_WhileInUse value) whileInUse,
    required TResult Function(_Always value) always,
    required TResult Function(_IsNull value) isNull,
    required TResult Function(_UnableToDetermine value) unableToDetermine,
  }) {
    return denied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Denied value)? denied,
    TResult? Function(_DeniedForever value)? deniedForever,
    TResult? Function(_WhileInUse value)? whileInUse,
    TResult? Function(_Always value)? always,
    TResult? Function(_IsNull value)? isNull,
    TResult? Function(_UnableToDetermine value)? unableToDetermine,
  }) {
    return denied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    TResult Function(_WhileInUse value)? whileInUse,
    TResult Function(_Always value)? always,
    TResult Function(_IsNull value)? isNull,
    TResult Function(_UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (denied != null) {
      return denied(this);
    }
    return orElse();
  }
}

abstract class _Denied implements SpeedFailure {
  const factory _Denied() = _$_Denied;
}

/// @nodoc
abstract class _$$_DeniedForeverCopyWith<$Res> {
  factory _$$_DeniedForeverCopyWith(
          _$_DeniedForever value, $Res Function(_$_DeniedForever) then) =
      __$$_DeniedForeverCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DeniedForeverCopyWithImpl<$Res>
    extends _$SpeedFailureCopyWithImpl<$Res, _$_DeniedForever>
    implements _$$_DeniedForeverCopyWith<$Res> {
  __$$_DeniedForeverCopyWithImpl(
      _$_DeniedForever _value, $Res Function(_$_DeniedForever) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_DeniedForever implements _DeniedForever {
  const _$_DeniedForever();

  @override
  String toString() {
    return 'SpeedFailure.deniedForever()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_DeniedForever);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() isNull,
    required TResult Function() unableToDetermine,
  }) {
    return deniedForever();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? isNull,
    TResult? Function()? unableToDetermine,
  }) {
    return deniedForever?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? isNull,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (deniedForever != null) {
      return deniedForever();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
    required TResult Function(_WhileInUse value) whileInUse,
    required TResult Function(_Always value) always,
    required TResult Function(_IsNull value) isNull,
    required TResult Function(_UnableToDetermine value) unableToDetermine,
  }) {
    return deniedForever(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Denied value)? denied,
    TResult? Function(_DeniedForever value)? deniedForever,
    TResult? Function(_WhileInUse value)? whileInUse,
    TResult? Function(_Always value)? always,
    TResult? Function(_IsNull value)? isNull,
    TResult? Function(_UnableToDetermine value)? unableToDetermine,
  }) {
    return deniedForever?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    TResult Function(_WhileInUse value)? whileInUse,
    TResult Function(_Always value)? always,
    TResult Function(_IsNull value)? isNull,
    TResult Function(_UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (deniedForever != null) {
      return deniedForever(this);
    }
    return orElse();
  }
}

abstract class _DeniedForever implements SpeedFailure {
  const factory _DeniedForever() = _$_DeniedForever;
}

/// @nodoc
abstract class _$$_WhileInUseCopyWith<$Res> {
  factory _$$_WhileInUseCopyWith(
          _$_WhileInUse value, $Res Function(_$_WhileInUse) then) =
      __$$_WhileInUseCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_WhileInUseCopyWithImpl<$Res>
    extends _$SpeedFailureCopyWithImpl<$Res, _$_WhileInUse>
    implements _$$_WhileInUseCopyWith<$Res> {
  __$$_WhileInUseCopyWithImpl(
      _$_WhileInUse _value, $Res Function(_$_WhileInUse) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_WhileInUse implements _WhileInUse {
  const _$_WhileInUse();

  @override
  String toString() {
    return 'SpeedFailure.whileInUse()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_WhileInUse);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() isNull,
    required TResult Function() unableToDetermine,
  }) {
    return whileInUse();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? isNull,
    TResult? Function()? unableToDetermine,
  }) {
    return whileInUse?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? isNull,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (whileInUse != null) {
      return whileInUse();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
    required TResult Function(_WhileInUse value) whileInUse,
    required TResult Function(_Always value) always,
    required TResult Function(_IsNull value) isNull,
    required TResult Function(_UnableToDetermine value) unableToDetermine,
  }) {
    return whileInUse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Denied value)? denied,
    TResult? Function(_DeniedForever value)? deniedForever,
    TResult? Function(_WhileInUse value)? whileInUse,
    TResult? Function(_Always value)? always,
    TResult? Function(_IsNull value)? isNull,
    TResult? Function(_UnableToDetermine value)? unableToDetermine,
  }) {
    return whileInUse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    TResult Function(_WhileInUse value)? whileInUse,
    TResult Function(_Always value)? always,
    TResult Function(_IsNull value)? isNull,
    TResult Function(_UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (whileInUse != null) {
      return whileInUse(this);
    }
    return orElse();
  }
}

abstract class _WhileInUse implements SpeedFailure {
  const factory _WhileInUse() = _$_WhileInUse;
}

/// @nodoc
abstract class _$$_AlwaysCopyWith<$Res> {
  factory _$$_AlwaysCopyWith(_$_Always value, $Res Function(_$_Always) then) =
      __$$_AlwaysCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AlwaysCopyWithImpl<$Res>
    extends _$SpeedFailureCopyWithImpl<$Res, _$_Always>
    implements _$$_AlwaysCopyWith<$Res> {
  __$$_AlwaysCopyWithImpl(_$_Always _value, $Res Function(_$_Always) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Always implements _Always {
  const _$_Always();

  @override
  String toString() {
    return 'SpeedFailure.always()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Always);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() isNull,
    required TResult Function() unableToDetermine,
  }) {
    return always();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? isNull,
    TResult? Function()? unableToDetermine,
  }) {
    return always?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? isNull,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (always != null) {
      return always();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
    required TResult Function(_WhileInUse value) whileInUse,
    required TResult Function(_Always value) always,
    required TResult Function(_IsNull value) isNull,
    required TResult Function(_UnableToDetermine value) unableToDetermine,
  }) {
    return always(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Denied value)? denied,
    TResult? Function(_DeniedForever value)? deniedForever,
    TResult? Function(_WhileInUse value)? whileInUse,
    TResult? Function(_Always value)? always,
    TResult? Function(_IsNull value)? isNull,
    TResult? Function(_UnableToDetermine value)? unableToDetermine,
  }) {
    return always?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    TResult Function(_WhileInUse value)? whileInUse,
    TResult Function(_Always value)? always,
    TResult Function(_IsNull value)? isNull,
    TResult Function(_UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (always != null) {
      return always(this);
    }
    return orElse();
  }
}

abstract class _Always implements SpeedFailure {
  const factory _Always() = _$_Always;
}

/// @nodoc
abstract class _$$_IsNullCopyWith<$Res> {
  factory _$$_IsNullCopyWith(_$_IsNull value, $Res Function(_$_IsNull) then) =
      __$$_IsNullCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_IsNullCopyWithImpl<$Res>
    extends _$SpeedFailureCopyWithImpl<$Res, _$_IsNull>
    implements _$$_IsNullCopyWith<$Res> {
  __$$_IsNullCopyWithImpl(_$_IsNull _value, $Res Function(_$_IsNull) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_IsNull implements _IsNull {
  const _$_IsNull();

  @override
  String toString() {
    return 'SpeedFailure.isNull()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_IsNull);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() isNull,
    required TResult Function() unableToDetermine,
  }) {
    return isNull();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? isNull,
    TResult? Function()? unableToDetermine,
  }) {
    return isNull?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? isNull,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (isNull != null) {
      return isNull();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
    required TResult Function(_WhileInUse value) whileInUse,
    required TResult Function(_Always value) always,
    required TResult Function(_IsNull value) isNull,
    required TResult Function(_UnableToDetermine value) unableToDetermine,
  }) {
    return isNull(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Denied value)? denied,
    TResult? Function(_DeniedForever value)? deniedForever,
    TResult? Function(_WhileInUse value)? whileInUse,
    TResult? Function(_Always value)? always,
    TResult? Function(_IsNull value)? isNull,
    TResult? Function(_UnableToDetermine value)? unableToDetermine,
  }) {
    return isNull?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    TResult Function(_WhileInUse value)? whileInUse,
    TResult Function(_Always value)? always,
    TResult Function(_IsNull value)? isNull,
    TResult Function(_UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (isNull != null) {
      return isNull(this);
    }
    return orElse();
  }
}

abstract class _IsNull implements SpeedFailure {
  const factory _IsNull() = _$_IsNull;
}

/// @nodoc
abstract class _$$_UnableToDetermineCopyWith<$Res> {
  factory _$$_UnableToDetermineCopyWith(_$_UnableToDetermine value,
          $Res Function(_$_UnableToDetermine) then) =
      __$$_UnableToDetermineCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UnableToDetermineCopyWithImpl<$Res>
    extends _$SpeedFailureCopyWithImpl<$Res, _$_UnableToDetermine>
    implements _$$_UnableToDetermineCopyWith<$Res> {
  __$$_UnableToDetermineCopyWithImpl(
      _$_UnableToDetermine _value, $Res Function(_$_UnableToDetermine) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UnableToDetermine implements _UnableToDetermine {
  const _$_UnableToDetermine();

  @override
  String toString() {
    return 'SpeedFailure.unableToDetermine()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_UnableToDetermine);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() denied,
    required TResult Function() deniedForever,
    required TResult Function() whileInUse,
    required TResult Function() always,
    required TResult Function() isNull,
    required TResult Function() unableToDetermine,
  }) {
    return unableToDetermine();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? denied,
    TResult? Function()? deniedForever,
    TResult? Function()? whileInUse,
    TResult? Function()? always,
    TResult? Function()? isNull,
    TResult? Function()? unableToDetermine,
  }) {
    return unableToDetermine?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? denied,
    TResult Function()? deniedForever,
    TResult Function()? whileInUse,
    TResult Function()? always,
    TResult Function()? isNull,
    TResult Function()? unableToDetermine,
    required TResult orElse(),
  }) {
    if (unableToDetermine != null) {
      return unableToDetermine();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Denied value) denied,
    required TResult Function(_DeniedForever value) deniedForever,
    required TResult Function(_WhileInUse value) whileInUse,
    required TResult Function(_Always value) always,
    required TResult Function(_IsNull value) isNull,
    required TResult Function(_UnableToDetermine value) unableToDetermine,
  }) {
    return unableToDetermine(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Denied value)? denied,
    TResult? Function(_DeniedForever value)? deniedForever,
    TResult? Function(_WhileInUse value)? whileInUse,
    TResult? Function(_Always value)? always,
    TResult? Function(_IsNull value)? isNull,
    TResult? Function(_UnableToDetermine value)? unableToDetermine,
  }) {
    return unableToDetermine?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Denied value)? denied,
    TResult Function(_DeniedForever value)? deniedForever,
    TResult Function(_WhileInUse value)? whileInUse,
    TResult Function(_Always value)? always,
    TResult Function(_IsNull value)? isNull,
    TResult Function(_UnableToDetermine value)? unableToDetermine,
    required TResult orElse(),
  }) {
    if (unableToDetermine != null) {
      return unableToDetermine(this);
    }
    return orElse();
  }
}

abstract class _UnableToDetermine implements SpeedFailure {
  const factory _UnableToDetermine() = _$_UnableToDetermine;
}
